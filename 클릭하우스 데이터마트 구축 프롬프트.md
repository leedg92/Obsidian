# blockchain_logs_prod 데이터마트 설계

  

## 개요

목록/카운트 쿼리 성능 개선을 위해 `AggregatingMergeTree` 기반 데이터마트를 구축한다.

원본 테이블에 INSERT 발생 시 Materialized View가 자동으로 집계 테이블에 반영한다.

  

## 현재 병목

- 목록 쿼리: 전체 row를 GROUP BY service_key → argMaxIf 11개 컬럼 집계 → ORDER BY → LIMIT 20

- 1주일 기준 28만 그룹, 약 1,000ms 소요

- 3주일 기준 70만 그룹, 약 3,459ms 소요

- keyword 검색이 GROUP BY 이전 WHERE에서 동작하여 검색 조건과 표시 데이터 불일치 문제 존재

  

## 구조

  

```

blockchain_logs_prod (원본)

│ INSERT

▼

blockchain_logs_mart_mv (Materialized View - 트리거)

│

▼

blockchain_logs_mart (AggregatingMergeTree - 집계 저장)

```

  

## 1. 집계 테이블 DDL

  

```sql

CREATE TABLE logs.blockchain_logs_mart

(

service_key String,

latest_timestamp SimpleAggregateFunction(max, DateTime64(3, 'Asia/Seoul')),

agg_service_type AggregateFunction(argMax, LowCardinality(String), DateTime64(3, 'Asia/Seoul')),

agg_con_no AggregateFunction(argMax, String, DateTime64(3, 'Asia/Seoul')),

agg_in_out AggregateFunction(argMax, LowCardinality(String), DateTime64(3, 'Asia/Seoul')),

agg_func_name AggregateFunction(argMax, String, DateTime64(3, 'Asia/Seoul')),

agg_terminal AggregateFunction(argMax, String, DateTime64(3, 'Asia/Seoul')),

agg_truck_no AggregateFunction(argMax, String, DateTime64(3, 'Asia/Seoul')),

agg_in_terminal AggregateFunction(argMax, String, DateTime64(3, 'Asia/Seoul')),

agg_out_terminal AggregateFunction(argMax, String, DateTime64(3, 'Asia/Seoul')),

has_container SimpleAggregateFunction(sum, UInt64),

has_group_func SimpleAggregateFunction(sum, UInt64),

date SimpleAggregateFunction(max, Date)

)

ENGINE = AggregatingMergeTree

PARTITION BY toYYYYMM(date)

ORDER BY service_key

SETTINGS index_granularity = 8192;

```

  

### 컬럼 설명

| 컬럼 | 타입 | 원본 쿼리 대응 |

|------|------|---------------|

| latest_timestamp | SimpleAggregateFunction(max) | max(timestamp) |

| agg_service_type | AggregateFunction(argMax) | argMaxIf(lower(service_type), timestamp, service_type != '') |

| agg_con_no | AggregateFunction(argMax) | argMaxIf(con_no, timestamp, con_no != '') |

| agg_in_out | AggregateFunction(argMax) | argMaxIf(in_out, timestamp, in_out != '') |

| agg_func_name | AggregateFunction(argMax) | argMaxIf(func_name, timestamp, func_name != '') |

| agg_terminal | AggregateFunction(argMax) | argMaxIf(terminal, timestamp, terminal != '') |

| agg_truck_no | AggregateFunction(argMax) | argMaxIf(truck_no, timestamp, truck_no != '') |

| agg_in_terminal | AggregateFunction(argMax) | argMaxIf(in_terminal, timestamp, in_terminal != '') |

| agg_out_terminal | AggregateFunction(argMax) | argMaxIf(out_terminal, timestamp, out_terminal != '') |

| has_container | SimpleAggregateFunction(sum) | countIf(con_no != '' OR truck_no != '') |

| has_group_func | SimpleAggregateFunction(sum) | countIf(func_name LIKE '%Group%') |

| date | SimpleAggregateFunction(max) | 파티션 프루닝용 |

  

## 2. Materialized View DDL

  

```sql

CREATE MATERIALIZED VIEW logs.blockchain_logs_mart_mv

TO logs.blockchain_logs_mart

AS

SELECT

service_key,

max(timestamp) AS latest_timestamp,

argMaxIfState(lower(service_type), timestamp, service_type != '') AS agg_service_type,

argMaxIfState(con_no, timestamp, con_no != '') AS agg_con_no,

argMaxIfState(in_out, timestamp, in_out != '') AS agg_in_out,

argMaxIfState(func_name, timestamp, func_name != '') AS agg_func_name,

argMaxIfState(terminal, timestamp, terminal != '') AS agg_terminal,

argMaxIfState(truck_no, timestamp, truck_no != '') AS agg_truck_no,

argMaxIfState(in_terminal, timestamp, in_terminal != '') AS agg_in_terminal,

argMaxIfState(out_terminal, timestamp, out_terminal != '') AS agg_out_terminal,

countIfState(con_no != '' OR truck_no != '') AS has_container,

countIfState(func_name LIKE '%Group%') AS has_group_func,

max(toDate(timestamp)) AS date

FROM logs.blockchain_logs_prod

WHERE ((type = 'req' AND func_name != 'GetTransHistory')

OR (type = 'res' AND func_name = 'GetTransHistory'))

AND module = 'bc'

GROUP BY service_key;

```

  

> **MV WHERE 조건**: `type`, `module`, `func_name` 필터를 포함하여 목록 쿼리 대상 row만 집계한다.

> 마트 조회 시 이 조건들은 불필요.

  

## 3. 구축 순서 (기존 데이터 + 신규 데이터 동시 처리)

  

**순서가 중요하다.** MV를 먼저 만들어야 백필 중 신규 INSERT도 놓치지 않는다.

  

```

1) 마트 테이블 생성 (빈 테이블)

2) MV 생성 (이 시점부터 신규 INSERT 자동 처리)

3) 백필 실행 (기존 데이터 INSERT INTO ... SELECT)

```

  

백필과 MV가 같은 service_key에 대해 중복 row를 만들어도

AggregatingMergeTree가 merge하면 정확한 결과가 나오므로 문제없다.

  

### 백필 쿼리

  

```sql

INSERT INTO logs.blockchain_logs_mart

SELECT

service_key,

max(timestamp) AS latest_timestamp,

argMaxIfState(lower(service_type), timestamp, service_type != '') AS agg_service_type,

argMaxIfState(con_no, timestamp, con_no != '') AS agg_con_no,

argMaxIfState(in_out, timestamp, in_out != '') AS agg_in_out,

argMaxIfState(func_name, timestamp, func_name != '') AS agg_func_name,

argMaxIfState(terminal, timestamp, terminal != '') AS agg_terminal,

argMaxIfState(truck_no, timestamp, truck_no != '') AS agg_truck_no,

argMaxIfState(in_terminal, timestamp, in_terminal != '') AS agg_in_terminal,

argMaxIfState(out_terminal, timestamp, out_terminal != '') AS agg_out_terminal,

countIfState(con_no != '' OR truck_no != '') AS has_container,

countIfState(func_name LIKE '%Group%') AS has_group_func,

max(toDate(timestamp)) AS date

FROM logs.blockchain_logs_prod

WHERE ((type = 'req' AND func_name != 'GetTransHistory')

OR (type = 'res' AND func_name = 'GetTransHistory'))

AND module = 'bc'

GROUP BY service_key;

```

  

## 4. 마트 조회 쿼리 (목록)

  

서브쿼리 안에서 GROUP BY + Merge로 집계하고, 바깥 WHERE에서 필터링한다.

keyword 검색은 최신값(= 화면 표시값) 기준이므로 검색-표시 불일치가 없다.

  

```sql

SELECT * FROM (

SELECT

service_key,

latest_timestamp AS timestamp,

if(argMaxIfMerge(agg_terminal) != '',

terminal_to_en(argMaxIfMerge(agg_terminal)),

concat(terminal_to_en(argMaxIfMerge(agg_out_terminal)), '-', terminal_to_en(argMaxIfMerge(agg_in_terminal)))

) AS terminal,

if(argMaxIfMerge(agg_truck_no) != '', argMaxIfMerge(agg_truck_no), splitByChar('_', service_key)[2]) AS truck_no,

argMaxIfMerge(agg_con_no) AS con_no,

multiIf(

countIfMerge(has_container) = 0 AND position(service_key, '_') = 0, 'group',

countIfMerge(has_container) > 0 AND countIfMerge(has_group_func) > 0, 'group_tss',

argMaxIfMerge(agg_service_type)

) AS service_type,

argMaxIfMerge(agg_in_out) AS in_out,

argMaxIfMerge(agg_func_name) AS func_name

FROM logs.blockchain_logs_mart

WHERE date >= #{fromDate} AND date <= #{toDate}

GROUP BY service_key, latest_timestamp

)

WHERE 1 = 1

-- 서비스 타입 필터

<if test="serviceType != null and serviceType != ''">

AND service_type = #{serviceType}

</if>

-- 단일 터미널 필터

<if test="targetTerminal != null and targetTerminal != ''">

AND terminal = #{targetTerminal}

</if>

-- 다중 터미널 필터 (RBAC용)

<if test="targetTerminals != null and targetTerminals.size() > 0">

AND terminal IN

<foreach collection="targetTerminals" item="term" open="(" separator="," close=")">

#{term}

</foreach>

</if>

-- keyword 검색 (최신값 기준, 표시 데이터와 일치)

<if test="keyword != null and keyword != ''">

AND (position(service_key, #{keyword}) > 0

OR position(lower(func_name), lower(#{keyword})) > 0

OR position(con_no, #{keyword}) > 0

OR position(truck_no, #{keyword}) > 0

OR position(terminal, to_terminal_code(#{keyword})) > 0)

</if>

ORDER BY timestamp DESC

LIMIT #{pageSize} OFFSET #{offset};

```

  

## 5. 마트 조회 쿼리 (카운트)

  

```sql

SELECT count(*) AS total

FROM (

SELECT

service_key,

latest_timestamp AS timestamp,

if(argMaxIfMerge(agg_terminal) != '',

terminal_to_en(argMaxIfMerge(agg_terminal)),

concat(terminal_to_en(argMaxIfMerge(agg_out_terminal)), '-', terminal_to_en(argMaxIfMerge(agg_in_terminal)))

) AS terminal,

if(argMaxIfMerge(agg_truck_no) != '', argMaxIfMerge(agg_truck_no), splitByChar('_', service_key)[2]) AS truck_no,

argMaxIfMerge(agg_con_no) AS con_no,

multiIf(

countIfMerge(has_container) = 0 AND position(service_key, '_') = 0, 'group',

countIfMerge(has_container) > 0 AND countIfMerge(has_group_func) > 0, 'group_tss',

argMaxIfMerge(agg_service_type)

) AS service_type,

argMaxIfMerge(agg_in_out) AS in_out,

argMaxIfMerge(agg_func_name) AS func_name

FROM logs.blockchain_logs_mart

WHERE date >= #{fromDate} AND date <= #{toDate}

GROUP BY service_key, latest_timestamp

)

WHERE 1 = 1

<if test="serviceType != null and serviceType != ''">

AND service_type = #{serviceType}

</if>

<if test="targetTerminal != null and targetTerminal != ''">

AND terminal = #{targetTerminal}

</if>

<if test="targetTerminals != null and targetTerminals.size() > 0">

AND terminal IN

<foreach collection="targetTerminals" item="term" open="(" separator="," close=")">

#{term}

</foreach>

</if>

<if test="keyword != null and keyword != ''">

AND (position(service_key, #{keyword}) > 0

OR position(lower(func_name), lower(#{keyword})) > 0

OR position(con_no, #{keyword}) > 0

OR position(truck_no, #{keyword}) > 0

OR position(terminal, to_terminal_code(#{keyword})) > 0)

</if>;

```

  

## 6. 기존 쿼리 대비 개선점

  

| 항목 | 기존 (원본 테이블) | 마트 |

|------|-------------------|------|

| GROUP BY 대상 | 전체 row (수백만) | service_key당 1~수 행 (미merge 포함) |

| argMaxIf 계산 | 매 요청마다 전체 계산 | 저장된 state merge만 (경량) |

| keyword 검색 | WHERE (집계 전, 과거 로그도 매칭) | 서브쿼리 외부 WHERE (최신값 기준, 표시 데이터와 일치) |

| 검색-표시 불일치 | 있음 | 없음 |

| INSERT 영향 | 없음 | MV 자동 집계 (경량, 실시간 적재 문제없음) |

| 디스크 | 원본만 | 원본 + 집계 테이블 (매우 작음) |

  

## 8. 검증용 순수 SQL (ClickHouse에서 직접 실행)

  

### 목록 조회 (필터 없음, 1주일)

```sql

SELECT * FROM (

SELECT

service_key,

latest_timestamp AS timestamp,

if(argMaxIfMerge(agg_terminal) != '',

terminal_to_en(argMaxIfMerge(agg_terminal)),

concat(terminal_to_en(argMaxIfMerge(agg_out_terminal)), '-', terminal_to_en(argMaxIfMerge(agg_in_terminal)))

) AS terminal,

if(argMaxIfMerge(agg_truck_no) != '', argMaxIfMerge(agg_truck_no), splitByChar('_', service_key)[2]) AS truck_no,

argMaxIfMerge(agg_con_no) AS con_no,

multiIf(

countIfMerge(has_container) = 0 AND position(service_key, '_') = 0, 'group',

countIfMerge(has_container) > 0 AND countIfMerge(has_group_func) > 0, 'group_tss',

argMaxIfMerge(agg_service_type)

) AS service_type,

argMaxIfMerge(agg_in_out) AS in_out,

argMaxIfMerge(agg_func_name) AS func_name

FROM logs.blockchain_logs_mart

WHERE date >= '2026-02-01' AND date <= '2026-02-08'

GROUP BY service_key, latest_timestamp

)

ORDER BY timestamp DESC

LIMIT 20 OFFSET 0;

```

  

### 목록 조회 (keyword 검색)

```sql

SELECT * FROM (

SELECT

service_key,

latest_timestamp AS timestamp,

if(argMaxIfMerge(agg_terminal) != '',

terminal_to_en(argMaxIfMerge(agg_terminal)),

concat(terminal_to_en(argMaxIfMerge(agg_out_terminal)), '-', terminal_to_en(argMaxIfMerge(agg_in_terminal)))

) AS terminal,

if(argMaxIfMerge(agg_truck_no) != '', argMaxIfMerge(agg_truck_no), splitByChar('_', service_key)[2]) AS truck_no,

argMaxIfMerge(agg_con_no) AS con_no,

multiIf(

countIfMerge(has_container) = 0 AND position(service_key, '_') = 0, 'group',

countIfMerge(has_container) > 0 AND countIfMerge(has_group_func) > 0, 'group_tss',

argMaxIfMerge(agg_service_type)

) AS service_type,

argMaxIfMerge(agg_in_out) AS in_out,

argMaxIfMerge(agg_func_name) AS func_name

FROM logs.blockchain_logs_mart

WHERE date >= '2026-02-01' AND date <= '2026-02-08'

GROUP BY service_key, latest_timestamp

)

WHERE position(service_key, 'SEKU') > 0

OR position(lower(func_name), lower('SEKU')) > 0

OR position(con_no, 'SEKU') > 0

OR position(truck_no, 'SEKU') > 0

ORDER BY timestamp DESC

LIMIT 20 OFFSET 0;

```

  

### 카운트 (필터 없음)

```sql

SELECT count(*) AS total

FROM (

SELECT service_key

FROM logs.blockchain_logs_mart

WHERE date >= '2026-02-01' AND date <= '2026-02-08'

GROUP BY service_key

);

```

  

### 카운트 (keyword 검색)

```sql

SELECT count(*) AS total

FROM (

SELECT

service_key,

argMaxIfMerge(agg_con_no) AS con_no,

argMaxIfMerge(agg_truck_no) AS truck_no,

argMaxIfMerge(agg_func_name) AS func_name

FROM logs.blockchain_logs_mart

WHERE date >= '2026-02-01' AND date <= '2026-02-08'

GROUP BY service_key

)

WHERE position(service_key, 'SEKU') > 0

OR position(lower(func_name), lower('SEKU')) > 0

OR position(con_no, 'SEKU') > 0

OR position(truck_no, 'SEKU') > 0;

```

  

### 원본 테이블 대비 성능 비교용 (동일 조건)

```sql

-- 원본 목록 쿼리 (비교 기준)

SELECT

service_key,

max(timestamp) AS latest_timestamp,

argMaxIf(lower(service_type), timestamp, service_type != '') AS agg_service_type,

argMaxIf(con_no, timestamp, con_no != '') AS agg_con_no,

argMaxIf(in_out, timestamp, in_out != '') AS agg_in_out,

argMaxIf(func_name, timestamp, func_name != '') AS agg_func_name,

argMaxIf(terminal, timestamp, terminal != '') AS agg_terminal,

argMaxIf(truck_no, timestamp, truck_no != '') AS agg_truck_no,

argMaxIf(in_terminal, timestamp, in_terminal != '') AS agg_in_terminal,

argMaxIf(out_terminal, timestamp, out_terminal != '') AS agg_out_terminal,

countIf(con_no != '' OR truck_no != '') AS has_container,

countIf(func_name LIKE '%Group%') AS has_group_func

FROM logs.blockchain_logs_prod

WHERE ((type = 'req' AND func_name != 'GetTransHistory')

OR (type = 'res' AND func_name = 'GetTransHistory'))

AND module = 'bc'

AND date >= '2026-02-01' AND date <= '2026-02-08'

AND timestamp >= '2026-02-01 00:00:00' AND timestamp <= '2026-02-08 23:59:59'

GROUP BY service_key

ORDER BY latest_timestamp DESC

LIMIT 20 OFFSET 0;

```

  

## 9. 주의사항

  

- **같은 service_key로 로그 추가 적재 시**: MV가 부분 집계 row를 mart에 append → SELECT 시 GROUP BY + Merge 함수가 자동 합산 → 백그라운드에서 물리적 merge. UPDATE가 아닌 append 방식이라 실시간 적재에 문제 없음.

- **timestamp 범위 필터**: 마트의 `date`는 service_key의 최신 날짜. 일 단위 범위 필터로 파티션 프루닝 활용.

- **AggregateFunction 컬럼은 WHERE에서 직접 비교 불가**: 반드시 GROUP BY + Merge 함수를 거친 후 서브쿼리 외부에서 필터링.