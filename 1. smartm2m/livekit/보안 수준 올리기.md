# LiveKit 보안 강화 가이드

  

## 🎯 개요

LiveKit 서버의 주요 보안 취약점을 해결하고 프로덕션 환경에서 안전하게 운영하기 위한 실용적 가이드입니다.

  

## 🔴 우선순위 1: 필수 보안 조치

  

### 1. 방화벽 포트 제한

```bash

# Ubuntu/Debian

sudo ufw enable

sudo ufw allow 7880/tcp        # LiveKit 메인 서비스

sudo ufw allow 7881/tcp        # WebRTC TCP 포트

sudo ufw allow 50000:60000/udp # WebRTC UDP 포트 범위

sudo ufw deny from any to any  # 기본 차단

  

# CentOS/RHEL

firewall-cmd --permanent --add-port=7880/tcp

firewall-cmd --permanent --add-port=7881/tcp

firewall-cmd --permanent --add-port=50000-60000/udp

firewall-cmd --reload

```

  

### 2. 커스텀 헤더 인증 구현

  

#### A) 새 파일 생성: `pkg/service/security_middleware.go`

```go

package service

  

import (

    "crypto/hmac"

    "crypto/sha256"

    "encoding/hex"

    "fmt"

    "net/http"

    "strconv"

    "time"

)

  

type SecurityMiddleware struct {

    secretKey      string

    allowedOrigins map[string]bool

}

  

func NewSecurityMiddleware(secretKey string, allowedOrigins []string) *SecurityMiddleware {

    origins := make(map[string]bool)

    for _, origin := range allowedOrigins {

        origins[origin] = true

    }

    return &SecurityMiddleware{secretKey: secretKey, allowedOrigins: origins}

}

  

func (m *SecurityMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {

    origin := r.Header.Get("Origin")

    if origin != "" && !m.allowedOrigins[origin] {

        authSignature := r.Header.Get("X-LiveKit-Auth-Signature")

        timestamp := r.Header.Get("X-LiveKit-Auth-Timestamp")

        if !m.validateSignature(authSignature, timestamp, origin) {

            http.Error(w, "Unauthorized origin", http.StatusForbidden)

            return

        }

    }

    next.ServeHTTP(w, r)

}

  

func (m *SecurityMiddleware) validateSignature(signature, timestamp, origin string) bool {

    ts, err := strconv.ParseInt(timestamp, 10, 64)

    if err != nil || time.Now().Unix()-ts > 300 { // 5분 유효

        return false

    }

    message := fmt.Sprintf("%s:%s", origin, timestamp)

    expectedSignature := m.generateSignature(message)

    return hmac.Equal([]byte(signature), []byte(expectedSignature))

}

  

func (m *SecurityMiddleware) generateSignature(message string) string {

    h := hmac.New(sha256.New, []byte(m.secretKey))

    h.Write([]byte(message))

    return hex.EncodeToString(h.Sum(nil))

}

```

  

#### B) 서버에 미들웨어 추가: `pkg/service/server.go`

```go

// middlewares 섹션에 추가

middlewares := []negroni.Handler{

    negroni.NewRecovery(),

    // 새로운 보안 미들웨어 추가

    NewSecurityMiddleware(conf.SecurityKey, conf.AllowedOrigins),

    // CORS 설정을 더 제한적으로 변경

    cors.New(cors.Options{

        AllowOriginFunc: func(origin string) bool {

            return false // 보안 미들웨어에서 처리

        },

        AllowedMethods: []string{"OPTIONS", "HEAD", "GET", "POST", "PATCH", "DELETE"},

        AllowedHeaders: []string{"*"},

        ExposedHeaders: []string{"*"},

        MaxAge: 86400,

    }),

    negroni.HandlerFunc(RemoveDoubleSlashes),

}

```

  

#### C) 설정 파일 수정: `config.yaml`

```yaml

# 기존 설정에 추가

security:

  auth_key: "your-super-secret-hmac-key-256-bit"

  allowed_origins:

    - "https://your-app.com"

    - "https://staging.your-app.com"

    - "http://localhost:3000"  # 개발용

  

keys:

  your-api-key: your-secret-key

```

  

#### D) 클라이언트 구현 예시

```javascript

// 프론트엔드에서 요청 시

function makeSecureRequest(url, data) {

    const origin = window.location.origin;

    const timestamp = Math.floor(Date.now() / 1000).toString();

    const message = `${origin}:${timestamp}`;

    const signature = CryptoJS.HmacSHA256(message, SECRET_KEY).toString();

    return fetch(url, {

        method: 'POST',

        headers: {

            'X-LiveKit-Auth-Signature': signature,

            'X-LiveKit-Auth-Timestamp': timestamp,

            'Authorization': `Bearer ${jwt_token}`,

        },

        body: JSON.stringify(data)

    });

}

```

  

## 🟡 우선순위 2: 권장 보안 조치

  

### 1. TLS/SSL 활성화

```yaml

# config.yaml에 추가

turn:

  enabled: true

  tls_port: 443

  domain: your-domain.com

  cert_file: /path/to/cert.pem

  key_file: /path/to/key.pem

# 또는 로드밸런서 사용시

turn:

  external_tls: true

  tls_port: 443

```

  

### 2. Docker 보안 강화

```yaml

# docker-compose.yml

version: '3.8'

services:

  livekit:

    build: .

    ports:

      - "7880:7880"

      - "7881:7881"

      - "50000-60000:50000-60000/udp"

    volumes:

      - ./config.yaml:/config.yaml:ro

    command: ["--config", "/config.yaml"]

    user: "1000:1000"  # 비root 사용자

    read_only: true

    security_opt:

      - no-new-privileges:true

```

  

## 🟢 우선순위 3: 선택적 보안 조치

  

### 1. 모니터링 설정

```yaml

# config.yaml

prometheus_port: 6789

  

logging:

  level: warn

  json: true

  sample: true

```

  

### 2. 리버스 프록시 (Nginx)

```nginx

server {

    listen 443 ssl;

    server_name your-domain.com;

    ssl_certificate /path/to/cert.pem;

    ssl_certificate_key /path/to/key.pem;

    location / {

        proxy_pass http://localhost:7880;

        proxy_set_header Host $host;

        proxy_set_header X-Real-IP $remote_addr;

        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    }

    # Rate limiting (선택사항)

    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

    limit_req zone=api burst=20 nodelay;

}

```

  

## ✅ 구현 체크리스트

  

### Phase 1 (필수)

- [ ] 방화벽 포트 제한 설정

- [ ] 커스텀 헤더 인증 미들웨어 구현

- [ ] 설정 파일에 보안 키 추가

- [ ] 클라이언트에서 헤더 서명 구현

  

### Phase 2 (권장)  

- [ ] TLS/SSL 인증서 설정

- [ ] Docker 보안 옵션 적용

- [ ] 모니터링 활성화

  

### Phase 3 (선택)

- [ ] 리버스 프록시 구성

- [ ] 로그 분석 시스템 구축

- [ ] 자동 보안 업데이트 설정

  

## 🚨 주의사항

  

1. **SECRET_KEY 관리**: 256비트 이상의 강력한 키 사용, 정기적 교체

2. **타임스탬프 동기화**: 서버-클라이언트 시간 차이 5분 이내 유지

3. **HTTPS 필수**: 프로덕션에서는 반드시 HTTPS 사용

4. **로그 모니터링**: 비정상적인 접근 시도 감시

  

## 📊 보안 효과

  

| 조치 | 차단 효과 | 구현 난이도 |

|------|-----------|-------------|

| 커스텀 헤더 인증 | 99%+ 악의적 요청 | 쉬움 |

| 방화벽 포트 제한 | 포트 스캔 공격 | 매우 쉬움 |

| TLS/SSL | 중간자 공격 | 쉬움 |

  

이 가이드를 따르면 LiveKit 서버를 안전하게 프로덕션 환경에 배포할 수 있습니다.