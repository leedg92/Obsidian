# LiveKit ë³´ì•ˆ ê°•í™” ê°€ì´ë“œ

  

## ğŸ¯ ê°œìš”

LiveKit ì„œë²„ì˜ ì£¼ìš” ë³´ì•ˆ ì·¨ì•½ì ì„ í•´ê²°í•˜ê³  í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ìš´ì˜í•˜ê¸° ìœ„í•œ ì‹¤ìš©ì  ê°€ì´ë“œì…ë‹ˆë‹¤.

  

## ğŸ”´ ìš°ì„ ìˆœìœ„ 1: í•„ìˆ˜ ë³´ì•ˆ ì¡°ì¹˜

  

### 1. ë°©í™”ë²½ í¬íŠ¸ ì œí•œ

```bash

# Ubuntu/Debian

sudo ufw enable

sudo ufw allow 7880/tcp Â  Â  Â  Â # LiveKit ë©”ì¸ ì„œë¹„ìŠ¤

sudo ufw allow 7881/tcp Â  Â  Â  Â # WebRTC TCP í¬íŠ¸

sudo ufw allow 50000:60000/udp # WebRTC UDP í¬íŠ¸ ë²”ìœ„

sudo ufw deny from any to any Â # ê¸°ë³¸ ì°¨ë‹¨

  

# CentOS/RHEL

firewall-cmd --permanent --add-port=7880/tcp

firewall-cmd --permanent --add-port=7881/tcp

firewall-cmd --permanent --add-port=50000-60000/udp

firewall-cmd --reload

```

  

### 2. ì»¤ìŠ¤í…€ í—¤ë” ì¸ì¦ êµ¬í˜„

  

#### A) ìƒˆ íŒŒì¼ ìƒì„±: `pkg/service/security_middleware.go`

```go

package service

  

import (

Â  Â  "crypto/hmac"

Â  Â  "crypto/sha256"

Â  Â  "encoding/hex"

Â  Â  "fmt"

Â  Â  "net/http"

Â  Â  "strconv"

Â  Â  "time"

)

  

type SecurityMiddleware struct {

Â  Â  secretKey Â  Â  Â string

Â  Â  allowedOrigins map[string]bool

}

  

func NewSecurityMiddleware(secretKey string, allowedOrigins []string) *SecurityMiddleware {

Â  Â  origins := make(map[string]bool)

Â  Â  for _, origin := range allowedOrigins {

Â  Â  Â  Â  origins[origin] = true

Â  Â  }

Â  Â  return &SecurityMiddleware{secretKey: secretKey, allowedOrigins: origins}

}

  

func (m *SecurityMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {

Â  Â  origin := r.Header.Get("Origin")

Â  Â  if origin != "" && !m.allowedOrigins[origin] {

Â  Â  Â  Â  authSignature := r.Header.Get("X-LiveKit-Auth-Signature")

Â  Â  Â  Â  timestamp := r.Header.Get("X-LiveKit-Auth-Timestamp")

Â  Â  Â  Â  if !m.validateSignature(authSignature, timestamp, origin) {

Â  Â  Â  Â  Â  Â  http.Error(w, "Unauthorized origin", http.StatusForbidden)

Â  Â  Â  Â  Â  Â  return

Â  Â  Â  Â  }

Â  Â  }

Â  Â  next.ServeHTTP(w, r)

}

  

func (m *SecurityMiddleware) validateSignature(signature, timestamp, origin string) bool {

Â  Â  ts, err := strconv.ParseInt(timestamp, 10, 64)

Â  Â  if err != nil || time.Now().Unix()-ts > 300 { // 5ë¶„ ìœ íš¨

Â  Â  Â  Â  return false

Â  Â  }

Â  Â  message := fmt.Sprintf("%s:%s", origin, timestamp)

Â  Â  expectedSignature := m.generateSignature(message)

Â  Â  return hmac.Equal([]byte(signature), []byte(expectedSignature))

}

  

func (m *SecurityMiddleware) generateSignature(message string) string {

Â  Â  h := hmac.New(sha256.New, []byte(m.secretKey))

Â  Â  h.Write([]byte(message))

Â  Â  return hex.EncodeToString(h.Sum(nil))

}

```

  

#### B) ì„œë²„ì— ë¯¸ë“¤ì›¨ì–´ ì¶”ê°€: `pkg/service/server.go`

```go

// middlewares ì„¹ì…˜ì— ì¶”ê°€

middlewares := []negroni.Handler{

Â  Â  negroni.NewRecovery(),

Â  Â  // ìƒˆë¡œìš´ ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ ì¶”ê°€

Â  Â  NewSecurityMiddleware(conf.SecurityKey, conf.AllowedOrigins),

Â  Â  // CORS ì„¤ì •ì„ ë” ì œí•œì ìœ¼ë¡œ ë³€ê²½

Â  Â  cors.New(cors.Options{

Â  Â  Â  Â  AllowOriginFunc: func(origin string) bool {

Â  Â  Â  Â  Â  Â  return false // ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ì—ì„œ ì²˜ë¦¬

Â  Â  Â  Â  },

Â  Â  Â  Â  AllowedMethods: []string{"OPTIONS", "HEAD", "GET", "POST", "PATCH", "DELETE"},

Â  Â  Â  Â  AllowedHeaders: []string{"*"},

Â  Â  Â  Â  ExposedHeaders: []string{"*"},

Â  Â  Â  Â  MaxAge: 86400,

Â  Â  }),

Â  Â  negroni.HandlerFunc(RemoveDoubleSlashes),

}

```

  

#### C) ì„¤ì • íŒŒì¼ ìˆ˜ì •: `config.yaml`

```yaml

# ê¸°ì¡´ ì„¤ì •ì— ì¶”ê°€

security:

Â  auth_key: "your-super-secret-hmac-key-256-bit"

Â  allowed_origins:

Â  Â  - "https://your-app.com"

Â  Â  - "https://staging.your-app.com"

Â  Â  - "http://localhost:3000" Â # ê°œë°œìš©

  

keys:

Â  your-api-key: your-secret-key

```

  

#### D) í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„ ì˜ˆì‹œ

```javascript

// í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ìš”ì²­ ì‹œ

function makeSecureRequest(url, data) {

Â  Â  const origin = window.location.origin;

Â  Â  const timestamp = Math.floor(Date.now() / 1000).toString();

Â  Â  const message = `${origin}:${timestamp}`;

Â  Â  const signature = CryptoJS.HmacSHA256(message, SECRET_KEY).toString();

Â  Â  return fetch(url, {

Â  Â  Â  Â  method: 'POST',

Â  Â  Â  Â  headers: {

Â  Â  Â  Â  Â  Â  'X-LiveKit-Auth-Signature': signature,

Â  Â  Â  Â  Â  Â  'X-LiveKit-Auth-Timestamp': timestamp,

Â  Â  Â  Â  Â  Â  'Authorization': `Bearer ${jwt_token}`,

Â  Â  Â  Â  },

Â  Â  Â  Â  body: JSON.stringify(data)

Â  Â  });

}

```

  

## ğŸŸ¡ ìš°ì„ ìˆœìœ„ 2: ê¶Œì¥ ë³´ì•ˆ ì¡°ì¹˜

  

### 1. TLS/SSL í™œì„±í™”

```yaml

# config.yamlì— ì¶”ê°€

turn:

Â  enabled: true

Â  tls_port: 443

Â  domain: your-domain.com

Â  cert_file: /path/to/cert.pem

Â  key_file: /path/to/key.pem

# ë˜ëŠ” ë¡œë“œë°¸ëŸ°ì„œ ì‚¬ìš©ì‹œ

turn:

Â  external_tls: true

Â  tls_port: 443

```

  

### 2. Docker ë³´ì•ˆ ê°•í™”

```yaml

# docker-compose.yml

version: '3.8'

services:

Â  livekit:

Â  Â  build: .

Â  Â  ports:

Â  Â  Â  - "7880:7880"

Â  Â  Â  - "7881:7881"

Â  Â  Â  - "50000-60000:50000-60000/udp"

Â  Â  volumes:

Â  Â  Â  - ./config.yaml:/config.yaml:ro

Â  Â  command: ["--config", "/config.yaml"]

Â  Â  user: "1000:1000" Â # ë¹„root ì‚¬ìš©ì

Â  Â  read_only: true

Â  Â  security_opt:

Â  Â  Â  - no-new-privileges:true

```

  

## ğŸŸ¢ ìš°ì„ ìˆœìœ„ 3: ì„ íƒì  ë³´ì•ˆ ì¡°ì¹˜

  

### 1. ëª¨ë‹ˆí„°ë§ ì„¤ì •

```yaml

# config.yaml

prometheus_port: 6789

  

logging:

Â  level: warn

Â  json: true

Â  sample: true

```

  

### 2. ë¦¬ë²„ìŠ¤ í”„ë¡ì‹œ (Nginx)

```nginx

server {

Â  Â  listen 443 ssl;

Â  Â  server_name your-domain.com;

Â  Â  ssl_certificate /path/to/cert.pem;

Â  Â  ssl_certificate_key /path/to/key.pem;

Â  Â  location / {

Â  Â  Â  Â  proxy_pass http://localhost:7880;

Â  Â  Â  Â  proxy_set_header Host $host;

Â  Â  Â  Â  proxy_set_header X-Real-IP $remote_addr;

Â  Â  Â  Â  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

Â  Â  }

Â  Â  # Rate limiting (ì„ íƒì‚¬í•­)

Â  Â  limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

Â  Â  limit_req zone=api burst=20 nodelay;

}

```

  

## âœ… êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

  

### Phase 1 (í•„ìˆ˜)

- [ ] ë°©í™”ë²½ í¬íŠ¸ ì œí•œ ì„¤ì •

- [ ] ì»¤ìŠ¤í…€ í—¤ë” ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„

- [ ] ì„¤ì • íŒŒì¼ì— ë³´ì•ˆ í‚¤ ì¶”ê°€

- [ ] í´ë¼ì´ì–¸íŠ¸ì—ì„œ í—¤ë” ì„œëª… êµ¬í˜„

  

### Phase 2 (ê¶Œì¥) Â 

- [ ] TLS/SSL ì¸ì¦ì„œ ì„¤ì •

- [ ] Docker ë³´ì•ˆ ì˜µì…˜ ì ìš©

- [ ] ëª¨ë‹ˆí„°ë§ í™œì„±í™”

  

### Phase 3 (ì„ íƒ)

- [ ] ë¦¬ë²„ìŠ¤ í”„ë¡ì‹œ êµ¬ì„±

- [ ] ë¡œê·¸ ë¶„ì„ ì‹œìŠ¤í…œ êµ¬ì¶•

- [ ] ìë™ ë³´ì•ˆ ì—…ë°ì´íŠ¸ ì„¤ì •

  

## ğŸš¨ ì£¼ì˜ì‚¬í•­

  

1. **SECRET_KEY ê´€ë¦¬**: 256ë¹„íŠ¸ ì´ìƒì˜ ê°•ë ¥í•œ í‚¤ ì‚¬ìš©, ì •ê¸°ì  êµì²´

2. **íƒ€ì„ìŠ¤íƒ¬í”„ ë™ê¸°í™”**: ì„œë²„-í´ë¼ì´ì–¸íŠ¸ ì‹œê°„ ì°¨ì´ 5ë¶„ ì´ë‚´ ìœ ì§€

3. **HTTPS í•„ìˆ˜**: í”„ë¡œë•ì…˜ì—ì„œëŠ” ë°˜ë“œì‹œ HTTPS ì‚¬ìš©

4. **ë¡œê·¸ ëª¨ë‹ˆí„°ë§**: ë¹„ì •ìƒì ì¸ ì ‘ê·¼ ì‹œë„ ê°ì‹œ

  

## ğŸ“Š ë³´ì•ˆ íš¨ê³¼

  

| ì¡°ì¹˜ | ì°¨ë‹¨ íš¨ê³¼ | êµ¬í˜„ ë‚œì´ë„ |

|------|-----------|-------------|

| ì»¤ìŠ¤í…€ í—¤ë” ì¸ì¦ | 99%+ ì•…ì˜ì  ìš”ì²­ | ì‰¬ì›€ |

| ë°©í™”ë²½ í¬íŠ¸ ì œí•œ | í¬íŠ¸ ìŠ¤ìº” ê³µê²© | ë§¤ìš° ì‰¬ì›€ |

| TLS/SSL | ì¤‘ê°„ì ê³µê²© | ì‰¬ì›€ |

  

ì´ ê°€ì´ë“œë¥¼ ë”°ë¥´ë©´ LiveKit ì„œë²„ë¥¼ ì•ˆì „í•˜ê²Œ í”„ë¡œë•ì…˜ í™˜ê²½ì— ë°°í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.