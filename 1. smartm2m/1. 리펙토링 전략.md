# VbsInvokeAlarmController 리팩토링 전략 비교

## 1. 두 가지 접근 방식 비교

### 1.1 명령형 방식 (고려)
```java
@RestController
public class VbsInvokeAlarmController {
    @PostMapping("/alarm")
    public ApiResponse handleVbsAlarm(VbsInvokeAlarmParam param) {
        String serverType = env.getProperty("serverName");
        
        // 서버 타입별 처리
        switch (serverType) {
            case "allcone": handleAllconeServer(param); break;
            case "bctrans": handleBctransServer(param); break;
            default: handleBothServers(param);
        }
    }

    private void handleTerminalEvent(Map<String, Object> message, VbsInvokeAlarmParam param) {
        if (param.isEmptyConInspectionResult()) {
            updateStatus(message, "EMPTY_CON_INSPTN_RESULT", "conInspectionTime");
        } else if (param.isCpsArrival()) {
            updateStatus(message, "CPS_ARRIVAL", "cpsStatusDT");
        }
        // ... 기타 이벤트 처리
    }
}
```

### 1.2 전략 패턴 적용
```java
// 이벤트 처리 전략 인터페이스
public interface EventHandler {
    void handle(VbsInvokeAlarmParam param);
}

// 구체적인 이벤트 처리 구현
public class TerminalEventHandler implements EventHandler {
    @Override
    public void handle(VbsInvokeAlarmParam param) {
        Map<String, Object> message = param.getResultMessage().getMessage();
        if (param.isEmptyConInspectionResult()) {
            updateStatus(message, "EMPTY_CON_INSPTN_RESULT", "conInspectionTime");
        }
        // ... 기타 이벤트 처리
    }
}

// 컨트롤러
@RestController
public class VbsInvokeAlarmController {
    private final Map<String, EventHandler> eventHandlers;

    public VbsInvokeAlarmController() {
        this.eventHandlers = new HashMap<>();
        eventHandlers.put("TERMINAL", new TerminalEventHandler());
        eventHandlers.put("RESERVATION", new ReservationEventHandler());
        // ... 기타 핸들러 등록
    }

    @PostMapping("/alarm")
    public ApiResponse handleVbsAlarm(VbsInvokeAlarmParam param) {
        EventHandler handler = determineHandler(param);
        handler.handle(param);
        return ApiResponse.ok();
    }
}
```

## 2. 장단점 비교

### 2.1 명령형 방식
장점:
- 코드 흐름이 직관적이고 명확함
- 디버깅이 쉬움
- 진입 장벽이 낮음
- 즉각적인 수정이 용이

단점:
- 새로운 이벤트 추가 시 여러 곳 수정 필요
- 조건문이 늘어날수록 복잡도 증가
- 코드 중복 발생 가능성

### 2.2 전략 패턴
장점:
- 새로운 이벤트 추가가 용이 (핸들러만 추가)
- 코드 재사용성 증가
- 단일 책임 원칙 준수
- 테스트가 용이

단점:
- 초기 설계가 복잡
- 클래스 수 증가
- 러닝 커브 존재
- 간단한 로직에 과도한 구조가 될 수 있음

## 3. 현재 상황에서의 선택

### 3.1 현재: 명령형 방식 선택 이유
1. 현재 이벤트 수가 적음 (6-7개)
2. 각 이벤트 처리 로직이 단순
3. 팀의 즉각적인 생산성 중시
4. 유지보수 용이성

### 3.2 전략 패턴 도입 고려 시점
- 이벤트 타입이 10개 이상으로 증가할 때
- 이벤트 처리 로직이 복잡해질 때
- 코드 재사용 필요성이 높아질 때

## 4. PPT 구성 제안

1. **도입 (1장)**
   - 리팩토링 목적
   - 현재 코드 구조

2. **두 가지 접근법 소개 (2장)**
   - 명령형 방식 특징
   - 전략 패턴 설명

3. **코드 비교 (2장)**
   - 실제 코드 예시
   - 구조 차이점

4. **장단점 분석 (1장)**
   - 비교표
   - 시각적 자료

5. **의사결정 (1장)**
   - 선택 근거
   - 향후 계획

6. **마무리 (1장)**
   - 요약
   - Q&A 준비

### 발표 시 강조점
1. 실용성 중심의 판단
2. 과도한 엔지니어링 지양
3. 팀 생산성 고려
4. 향후 확장성 고려

이렇게 두 가지 방식을 명확하게 비교하고, 현재 상황에 맞는 선택을 제시하는 것이 좋을 것 같습니다.
