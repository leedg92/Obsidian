# VbsInvokeAlarmController 리팩토링 전략 비교

## 1. 두 가지 접근 방식 비교

### 1.1 명령형 방식 (고려)
```java
@RestController
public class VbsInvokeAlarmController {
    @PostMapping("/alarm")
    public ApiResponse handleVbsAlarm(VbsInvokeAlarmParam param) {
        String serverType = env.getProperty("serverName");
        
        // 서버 타입별 처리
        switch (serverType) {
            case "allcone": handleAllconeServer(param); break;
            case "bctrans": handleBctransServer(param); break;
            default: handleBothServers(param);
        }
    }

    private void handleTerminalEvent(Map<String, Object> message, VbsInvokeAlarmParam param) {
        if (param.isEmptyConInspectionResult()) {
            updateStatus(message, "EMPTY_CON_INSPTN_RESULT", "conInspectionTime");
        } else if (param.isCpsArrival()) {
            updateStatus(message, "CPS_ARRIVAL", "cpsStatusDT");
        }
        // ... 기타 이벤트 처리
    }
}
```

## 2. 고려해볼만한 방식 - 명령형

### 어쨌든 목적은 유지보수, 수정, 추가 개발이 용이하게 만드는게 리펙토링의 목적이라는 전제 하에...

### 2.1 명령형 방식 선택 이유
1. 현재 이벤트 수가 적음 (6-7개)
	- 더 늘어날려나..?
2. 각 이벤트 처리 로직이 단순
3. 팀의 즉각적인 생산성 중시
	- 유지보수를 우리가 맡던 아니던 처음 코드를 보는 개발자 입장에서 패턴 적용에 의해 파일을 왔다갔다하는 것 보다 단순화가 더 나을 수도 있다는 판단
	- 패턴 적용 시의 러닝커브도 고려해봐야함
4. 유지보수 용이성

### 2.2 패턴 도입 고려 시점
- 이벤트 타입이 10개 이상으로 증가할 때
- 이벤트 처리 로직이 복잡해질 때
- 코드 재사용 필요성이 높아질 때

## 3. PPT 구성안

1. **도입 (1장)**
   - 리팩토링 목적
   - 현재 코드 구조

2. **두 가지 접근법 소개 (2장)**
   - 명령형 방식 특징
   - 전략 패턴 설명

3. **코드 비교 (2장)**
   - 실제 코드 예시
   - 구조 차이점

4. **장단점 분석 (1장)**
   - 비교표
   - 시각적 자료

5. **의사결정 (1장)**
   - 선택 근거
   - 향후 계획

6. **마무리 (1장)**
   - 요약
   - Q&A 준비

### 발표 시 강조점
1. 실용성 중심의 판단
2. 과도한 엔지니어링 지양
3. 팀 생산성 고려
4. 향후 확장성 고려

이렇게 두 가지 방식을 명확하게 비교하고, 현재 상황에 맞는 선택을 제시하는 것이 좋을 것 같습니다.
