ë„¤, ì½”ë“œë² ì´ìŠ¤ë¥¼ ë³´ë©´ì„œ ìƒì„¸í•˜ê²Œ íë¦„ì„ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤!
Ran tool

Read file: src/plugins/scheduler.ts

Read file: src/config/healthcheckTasks.ts

Read file: src/services/schedule/healthcheckService.ts

Read file: src/services/schedule/terminalProcessor.service.ts

Read file: src/services/schedule/httpClient.service.ts

Read file: src/repositories/schedule/memory.repository.ts

Read file: src/repositories/schedule/endpoints.repository.ts

Ran tool

ë„¤, ì½”ë“œë² ì´ìŠ¤ë¥¼ ë³´ë©´ì„œ ìƒì„¸í•˜ê²Œ íë¦„ì„ ì„¤ëª…í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤!

## ğŸš€ **1ë‹¨ê³„: ì„œë²„ ì‹œì‘ ë° ìŠ¤ì¼€ì¤„ëŸ¬ ë“±ë¡**

### `src/app.ts` (ì„œë²„ ì‹œì‘)
```typescript
// í”ŒëŸ¬ê·¸ì¸ ì§ì ‘ ë¡œë“œ
await fastify.register(import('./plugins/scheduler.js'));
```

### `src/plugins/scheduler.ts` (ìŠ¤ì¼€ì¤„ëŸ¬ í”ŒëŸ¬ê·¸ì¸)
```typescript
// í—¬ìŠ¤ì²´í¬ ë°°ì¹˜ ì‘ì—… ë“±ë¡
const healthcheckTaskFunction = async () => {
    await healthcheckTask.task(fastify);  // â† ì´ ë¶€ë¶„ì´ ì‹¤ì œ ë°°ì¹˜ ì‹¤í–‰
};

tasks.set(healthcheckTask.name, {
    name: healthcheckTask.name,
    pattern: healthcheckTask.pattern,   // "* * * * *" (1ë¶„ë§ˆë‹¤)
    task: healthcheckTaskFunction
});
```

### `src/config/healthcheckTasks.ts` (ì‘ì—… ì •ì˜)
```typescript
export const healthcheckTask = {
    name: 'healthcheck-batch',
    pattern: '* * * * *',  // 1ë¶„ë§ˆë‹¤ ì‹¤í–‰
    task: async (fastify: FastifyInstance): Promise<void> => {
        const healthcheckService = new HealthcheckService(fastify);
        const result = await healthcheckService.executeHealthcheck();  // â† í•µì‹¬ ì‹¤í–‰
    }
};
```

## â° **2ë‹¨ê³„: 1ë¶„ë§ˆë‹¤ ë°°ì¹˜ ì‹¤í–‰**

### `src/plugins/scheduler.ts` (cron ì‹¤í–‰)
```typescript
taskInfo.cronJob = cron.schedule(taskInfo.pattern, async () => {
    taskInfo.running = true;
    try {
        await taskInfo.task();  // â† healthcheckTask.task() í˜¸ì¶œ
    } finally {
        taskInfo.running = false;
    }
});
```

## ğŸ“Š **3ë‹¨ê³„: í—¬ìŠ¤ì²´í¬ ë°°ì¹˜ ì‹œì‘**

### `src/services/schedule/healthcheckService.ts`
```typescript
async executeHealthcheck(): Promise<BatchResult> {
    // 1. í™œì„± ì—”ë“œí¬ì¸íŠ¸ ì¡°íšŒ
    const endpoints = await this.endpointsRepo.getActiveEndpoints();
    
    // 2. í„°ë¯¸ë„ë³„ë¡œ ê·¸ë£¹í™”
    const terminalGroups = this.groupEndpointsByTerminal(endpoints);
    
    // 3. ê° í„°ë¯¸ë„ë³„ë¡œ ë¹„ë™ê¸° ë³‘ë ¬ ì²˜ë¦¬
    const terminalResults = await Promise.allSettled(
        Array.from(terminalGroups.entries()).map(([terminalName, terminalEndpoints]) =>
            this.terminalProcessor.processTerminal(terminalName, terminalEndpoints)
        )
    );
}
```

## ğŸ—ƒï¸ **4ë‹¨ê³„: ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì—”ë“œí¬ì¸íŠ¸ ì¡°íšŒ**

### `src/repositories/schedule/endpoints.repository.ts`
```typescript
async getActiveEndpoints(): Promise<TerminalEndpoint[]> {
    const query = `
        SELECT terminal_name, metric_type, http_method, api_url, api_key
        FROM health_terminal_endpoints 
        WHERE is_active = 'Y'   // â† í™œì„± ì—”ë“œí¬ì¸íŠ¸ë§Œ ì¡°íšŒ
        ORDER BY terminal_name, metric_type
    `;
    
    const [rows] = await this.fastify.db.query<RowDataPacket[]>(query);
    return rows as TerminalEndpoint[];
}
```

**ê²°ê³¼ ì˜ˆì‹œ:**
```
PNC - memory, threads, deadlocks, health
HKTG - memory, threads, deadlocks, health
ALLCONE_API - memory, threads, deadlocks, health
... (ì´ 12ê°œ í„°ë¯¸ë„ x 4ê°œ ë©”íŠ¸ë¦­ = 48ê°œ ì—”ë“œí¬ì¸íŠ¸)
```

## ğŸ¢ **5ë‹¨ê³„: í„°ë¯¸ë„ë³„ ê·¸ë£¹í™”**

### `src/services/schedule/healthcheckService.ts`
```typescript
private groupEndpointsByTerminal(endpoints: TerminalEndpoint[]): Map<string, TerminalEndpoint[]> {
    const groups = new Map<string, TerminalEndpoint[]>();
    
    endpoints.forEach(endpoint => {
        const terminalName = endpoint.terminal_name;
        if (!groups.has(terminalName)) {
            groups.set(terminalName, []);
        }
        groups.get(terminalName)!.push(endpoint);  // â† í„°ë¯¸ë„ë³„ë¡œ ë¶„ë¥˜
    });
    
    return groups;
}
```

**ê²°ê³¼:**
```
Map {
  'PNC' => [memoryì—”ë“œí¬ì¸íŠ¸, threadsì—”ë“œí¬ì¸íŠ¸, deadlocksì—”ë“œí¬ì¸íŠ¸, healthì—”ë“œí¬ì¸íŠ¸],
  'HKTG' => [memoryì—”ë“œí¬ì¸íŠ¸, threadsì—”ë“œí¬ì¸íŠ¸, deadlocksì—”ë“œí¬ì¸íŠ¸, healthì—”ë“œí¬ì¸íŠ¸],
  ...
}
```

## ğŸ”„ **6ë‹¨ê³„: í„°ë¯¸ë„ë³„ ë³‘ë ¬ ì²˜ë¦¬**

### `src/services/schedule/terminalProcessor.service.ts`
```typescript
async processTerminal(terminalName: string, endpoints: TerminalEndpoint[]): Promise<TerminalProcessResult> {
    // ëª¨ë“  ì—”ë“œí¬ì¸íŠ¸ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
    const results = await Promise.allSettled(
        endpoints.map(endpoint => this.processEndpoint(endpoint))  // â† 4ê°œ ì—”ë“œí¬ì¸íŠ¸ ë™ì‹œ ì²˜ë¦¬
    );
    
    // ê²°ê³¼ ì§‘ê³„
    results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
            if (result.value.success) {
                successful++;
            } else {
                failed++;
            }
        }
    });
}
```

## ğŸŒ **7ë‹¨ê³„: ê°œë³„ ì—”ë“œí¬ì¸íŠ¸ HTTP ìš”ì²­**

### `src/services/schedule/terminalProcessor.service.ts`
```typescript
private async processEndpoint(endpoint: TerminalEndpoint): Promise<HealthcheckResult> {
    let responseData: any = null;
    let success = false;
    
    try {
        // HTTP ìš”ì²­ ì‹¤í–‰
        responseData = await this.httpClient.request(endpoint);  // â† ì‹¤ì œ HTTP í˜¸ì¶œ
        success = true;
    } catch (error: any) {
        responseData = { error: error.message, timestamp: new Date().toISOString() };
    }
    
    // ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´ ë°ì´í„° ì €ì¥
    await this.saveResponse(endpoint, responseData);  // â† ë¬´ì¡°ê±´ ì €ì¥
}
```

## ğŸ”— **8ë‹¨ê³„: HTTP ìš”ì²­ ì‹¤í–‰**

### `src/services/schedule/httpClient.service.ts`
```typescript
async request(endpoint: TerminalEndpoint): Promise<any> {
    const config: AxiosRequestConfig = {
        method: endpoint.http_method,    // GET ë˜ëŠ” POST
        url: endpoint.api_url,          // ì‹¤ì œ í„°ë¯¸ë„ API URL
        timeout: 30000,                 // 30ì´ˆ íƒ€ì„ì•„ì›ƒ
        headers: this.buildHeaders(endpoint)  // apiKey í—¤ë” í¬í•¨
    };
    
    const response: AxiosResponse = await axios(config);  // â† ì‹¤ì œ HTTP ìš”ì²­
    return response.data;
}
```

## ğŸ’¾ **9ë‹¨ê³„: ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥**

### `src/services/schedule/terminalProcessor.service.ts`
```typescript
private async saveResponse(endpoint: TerminalEndpoint, responseData: any): Promise<void> {
    const { terminal_name, metric_type } = endpoint;
    
    switch (metric_type) {
        case 'memory':
            await this.memoryRepo.insert(terminal_name, responseData);      // â† memory í…Œì´ë¸”ì— ì €ì¥
            break;
        case 'threads':
            await this.threadsRepo.insert(terminal_name, responseData);     // â† threads í…Œì´ë¸”ì— ì €ì¥
            break;
        case 'deadlocks':
            await this.deadlocksRepo.insert(terminal_name, responseData);   // â† deadlocks í…Œì´ë¸”ì— ì €ì¥
            break;
        case 'health':
            await this.healthStatusRepo.insert(terminal_name, responseData); // â† health í…Œì´ë¸”ì— ì €ì¥
            break;
    }
}
```

### `src/repositories/schedule/memory.repository.ts`
```typescript
async insert(terminalName: string, responseData: any): Promise<void> {
    const query = `
        INSERT INTO health_terminal_memory (terminal_name, response_data) 
        VALUES (?, ?)
    `;
    
    await this.fastify.db.query(query, [terminalName, JSON.stringify(responseData)]);
    //                                   â†‘ í„°ë¯¸ë„ëª…    â†‘ JSON ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
}
```

## ğŸ“ **10ë‹¨ê³„: ê²°ê³¼ ì§‘ê³„ ë° ë¡œê¹…**

### `src/services/schedule/healthcheckService.ts`
```typescript
private logBatchResult(result: BatchResult): void {
    this.fastify.logWithContext('info', 'í—¬ìŠ¤ì²´í¬ ë°°ì¹˜ ì™„ë£Œ', {
        terminals: {
            total: result.total_terminals,        // ì´ í„°ë¯¸ë„ ìˆ˜
            successful: result.successful_terminals,  // ì„±ê³µí•œ í„°ë¯¸ë„ ìˆ˜
            failed: result.failed_terminals       // ì‹¤íŒ¨í•œ í„°ë¯¸ë„ ìˆ˜
        },
        endpoints: {
            total: result.total_endpoints,        // ì´ ì—”ë“œí¬ì¸íŠ¸ ìˆ˜
            successful: result.successful_endpoints,  // ì„±ê³µí•œ ì—”ë“œí¬ì¸íŠ¸ ìˆ˜
            failed: result.failed_endpoints       // ì‹¤íŒ¨í•œ ì—”ë“œí¬ì¸íŠ¸ ìˆ˜
        }
    });
}
```

## ğŸ”„ **ì „ì²´ íë¦„ ìš”ì•½:**

1. **ì„œë²„ ì‹œì‘** â†’ ìŠ¤ì¼€ì¤„ëŸ¬ í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ â†’ í—¬ìŠ¤ì²´í¬ ì‘ì—… ë“±ë¡
2. **1ë¶„ë§ˆë‹¤** â†’ cronì´ `healthcheckTask.task()` ì‹¤í–‰
3. **ë°°ì¹˜ ì‹œì‘** â†’ `HealthcheckService.executeHealthcheck()` ì‹¤í–‰
4. **DB ì¡°íšŒ** â†’ `health_terminal_endpoints` í…Œì´ë¸”ì—ì„œ í™œì„± ì—”ë“œí¬ì¸íŠ¸ ì¡°íšŒ
5. **ê·¸ë£¹í™”** â†’ í„°ë¯¸ë„ë³„ë¡œ ì—”ë“œí¬ì¸íŠ¸ ë¶„ë¥˜ (PNC, HKTG, ALLCONE_API...)
6. **ë³‘ë ¬ ì²˜ë¦¬** â†’ ê° í„°ë¯¸ë„ì˜ 4ê°œ ì—”ë“œí¬ì¸íŠ¸ë¥¼ ë™ì‹œì— ì²˜ë¦¬
7. **HTTP ìš”ì²­** â†’ ì‹¤ì œ í„°ë¯¸ë„ API í˜¸ì¶œ (axios ì‚¬ìš©)
8. **ë°ì´í„° ì €ì¥** â†’ ì„±ê³µ/ì‹¤íŒ¨ ê´€ê³„ì—†ì´ ì ì ˆí•œ í…Œì´ë¸”ì— ì €ì¥
9. **ê²°ê³¼ ì§‘ê³„** â†’ ì„±ê³µ/ì‹¤íŒ¨ í†µê³„ ê³„ì‚°
10. **ë¡œê¹…** â†’ ìµœì¢… ê²°ê³¼ ë¡œê·¸ ì¶œë ¥

ì´ëŸ° ì‹ìœ¼ë¡œ ë§¤ ë¶„ë§ˆë‹¤ 48ê°œ ì—”ë“œí¬ì¸íŠ¸ì— HTTP ìš”ì²­ì„ ë³´ë‚´ê³ , ì‘ë‹µì„ DBì— ì €ì¥í•˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤!